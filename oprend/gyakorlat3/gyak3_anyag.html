<p><span style="text-decoration: underline;"><strong><span style="font-size: 18pt;">Folyamatkezel&eacute;s</span></strong></span></p>
<p><span style="font-size: 14pt;">A Linux oper&aacute;ci&oacute;s rendszer feladata t&ouml;bbek k&ouml;z&ouml;tt, hogy egy t&ouml;bbfeladatos, multitasking k&ouml;rnyezetet biztos&iacute;tson a felhaszn&aacute;l&oacute;k sz&aacute;m&aacute;ra, ahol egyszerre t&ouml;bb program (b&aacute;jthalmaz a mem&oacute;ri&aacute;ban) futhat egyidejűleg. A folyamatkezel&eacute;s az oper&aacute;ci&oacute;s rendszer egyik legfontosabb r&eacute;sze: az egyes folyamatok l&eacute;trehoz&aacute;sa, &uuml;temez&eacute;se, &aacute;llapotkezel&eacute;se, kiiktat&aacute;sa &eacute;s az erőforr&aacute;s-eloszt&aacute;s kezel&eacute;se mind-mind a rendszer l&eacute;nyeges tulajdons&aacute;gait k&eacute;pezik.&nbsp;</span></p>
<p><span style="text-decoration: underline;"><strong><span style="font-size: 14pt;">Folyamatok</span></strong></span></p>
<p><span style="font-size: 14pt;">A folyamat egy v&eacute;grehajt&aacute;s alatt &aacute;ll&oacute; program a mem&oacute;ri&aacute;ban &ndash; hivatkozhatunk r&aacute; egy akt&iacute;v entit&aacute;sk&eacute;nt, amely a passz&iacute;v programb&oacute;l k&eacute;sz&uuml;l. Folyamatok j&ouml;hetnek l&eacute;tre automatikusan, de hozhatunk l&eacute;tre mi is. Egy v&eacute;letlenszerűen kiv&aacute;lasztott C program eset&eacute;n a ford&iacute;t&aacute;s sor&aacute;n futtathat&oacute; &aacute;llom&aacute;nyt kapunk, amelyet a ./ karakterek seg&iacute;ts&eacute;g&eacute;vel futtatunk, &iacute;gy egy folyamatot k&eacute;sz&iacute;t&uuml;nk.&nbsp;</span></p>
<p><span style="font-size: 14pt;">A folyamat k&uuml;l&ouml;nb&ouml;ző r&eacute;szekre tagol&oacute;dik a mem&oacute;ri&aacute;ban, &eacute;s mindegyik m&aacute;s-m&aacute;s c&eacute;lra szolg&aacute;l.&nbsp;</span></p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://canvas.instructure.com/courses/13939147/files/331420107/preview" alt="Process_look.png" data-api-endpoint="https://canvas.instructure.com/api/v1/courses/13939147/files/331420107" data-api-returntype="File" /></p>
<p><span style="font-size: 14pt;">A sz&ouml;vegr&eacute;sz t&aacute;rolja egy sz&ouml;veg- vagy k&oacute;dszegmens v&eacute;grehajtand&oacute; utas&iacute;t&aacute;sait, amely gyakran csak olvashat&oacute; r&eacute;szk&eacute;nt funkcion&aacute;l. A verem ideiglenes adatokat tartalmaz, f&uuml;ggv&eacute;nyparam&eacute;tereket, visszat&eacute;r&eacute;si c&iacute;meket, lok&aacute;lis v&aacute;ltoz&oacute;kat. Az adatszakasz a glob&aacute;lis v&aacute;ltoz&oacute;kat tartalmazza, m&iacute;g a heapen a folyamat fut&aacute;si ideje alatt dinamikusan lefoglalt mem&oacute;ria l&aacute;that&oacute;.&nbsp;</span></p>
<p><span style="font-size: 14pt;">Egy folyamat sz&aacute;mos attrib&uacute;tummal rendelkezik, amelyek seg&iacute;tik az oper&aacute;ci&oacute;s rendszert a kezel&eacute;s&uuml;kben &eacute;s az ellenőrz&eacute;s&uuml;kben. Az attrib&uacute;tumok egy &uacute;gynevezett Process Cotrol Block (PCB) adatstrukt&uacute;r&aacute;ban t&aacute;rolhat&oacute;k. &Aacute;llapot&aacute;tmenetek sor&aacute;n az oper&aacute;ci&oacute;s rendszer friss&iacute;ti a PCB-t a legfrissebb v&eacute;grehajt&aacute;si adatokkal. A folyamatt&aacute;bla PCB-k t&ouml;mbje, amely az &ouml;sszes akt&iacute;v folyamat adatait t&aacute;rolja. A PCB fel&eacute;p&iacute;t&eacute;se:</span></p>
<ul>
<li><span style="font-size: 14pt;">Folyamatazonos&iacute;t&oacute; (PID): egy egyedi azonos&iacute;t&oacute;, amellyel minden oper&aacute;ci&oacute;s rendszerbeli folyamat rendelkezik.</span></li>
<li><span style="font-size: 14pt;">Sz&uuml;lőazonos&iacute;t&oacute; (PPID): a sz&uuml;lőfolyamat azonos&iacute;t&oacute;ja.</span></li>
<li><span style="font-size: 14pt;">Felhaszn&aacute;l&oacute;i jogosults&aacute;gok (UID, GID).</span></li>
<li><span style="font-size: 14pt;">&Aacute;llapot: a folyamat aktu&aacute;lis &aacute;llapot&aacute;t mutatja. Leggyakoribb &aacute;llapotok: fut&oacute;, fut&aacute;sra k&eacute;sz, blokkolt.</span></li>
<li><span style="font-size: 14pt;">CPU &aacute;llapot: kontextusv&aacute;lt&aacute;shoz sz&uuml;ks&eacute;ges adatokat tartalmaz, mint a CPU regisztereket, stack pointert, flageket &eacute;s a program countert (amely az utas&iacute;t&aacute;smutat&oacute;).</span></li>
<li><span style="font-size: 14pt;">&Uuml;temez&eacute;si inform&aacute;ci&oacute;k: az adott folyamat priorit&aacute;s&aacute;t, időkv&oacute;t&aacute;j&aacute;t (mennyi CPU időszeletet kaphat), valamint a sorok mutat&oacute;it tartalmazza.</span></li>
<li><span style="font-size: 14pt;">Mem&oacute;riakezel&eacute;si adatok.</span></li>
<li><span style="font-size: 14pt;">I/O erőforr&aacute;sok: mag&aacute;ba foglalja a megnyitott f&aacute;jlok list&aacute;j&aacute;t, az I/O eszk&ouml;z&ouml;k &aacute;llapot&aacute;t, lockokat &eacute;s szemaforokat.</span></li>
<li><span style="font-size: 14pt;">K&ouml;nyvel&eacute;si adatok.</span></li>
</ul>
<p><span style="font-size: 14pt;">Az al&aacute;bbi &aacute;bra megmutatja a folyamat lehets&eacute;ges &aacute;llapotai k&ouml;z&ouml;tti kapcsolatokat.</span></p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://canvas.instructure.com/courses/13939147/files/333252497/preview" alt="process-state-in-os.jpg" data-api-endpoint="https://canvas.instructure.com/api/v1/courses/13939147/files/333252497" data-api-returntype="File" /></p>
<p><span style="text-decoration: underline;"><strong><span style="font-size: 14pt;">Folyamatok l&eacute;trehoz&aacute;sa</span></strong></span></p>
<p><span style="font-size: 14pt;">Tanulm&aacute;nyaink sor&aacute;n C-ben programozunk, ahol a folyamatok l&eacute;trehoz&aacute;sa egy rendszerh&iacute;v&aacute;s seg&iacute;ts&eacute;g&eacute;vel, a Linuxban is haszn&aacute;lt fork()-kal t&ouml;rt&eacute;nik. A fork() megh&iacute;v&aacute;sakor az oper&aacute;ci&oacute;s rendszer l&eacute;trehoz egy &uacute;j processzt, ezzel szinte t&ouml;k&eacute;letesen lem&aacute;solva a sz&uuml;lőfolyamatot. A gyerekfolyamat saj&aacute;t azonos&iacute;t&oacute;t (PID) kap, a sz&uuml;lőazonos&iacute;t&oacute;ja (PPID) pedig az ősfolyamat ID-j&aacute;t kapja meg.</span></p>
<p><span style="font-size: 14pt;">A C-beli f&uuml;ggv&eacute;ny nem rendelkezik param&eacute;terekkel. Visszat&eacute;r&eacute;si &eacute;rt&eacute;ke egy pid_t t&iacute;pus&uacute; eg&eacute;sz sz&aacute;m, amely a sz&uuml;lő-gyerek folyamatok kapcsolat&aacute;t jelzi. Negat&iacute;v &eacute;rt&eacute;k, legt&ouml;bbsz&ouml;r -1 eset&eacute;n hib&aacute;t kapunk, &iacute;gy a gyerekfolyamat l&eacute;trehoz&aacute;sa nem siker&uuml;lt. Ha 0-val t&eacute;r vissza, a gyerekfolyamatot siker&uuml;lt l&eacute;trehozni. Pozit&iacute;v &eacute;rt&eacute;k eset&eacute;n a k&oacute;d a sz&uuml;lőfolyamatban fut.</span></p>
<p><span style="font-size: 14pt;">Szintaxisa:</span></p>
<pre>pid_t child = fork();</pre>
<p><span style="font-size: 14pt;">Tegy&uuml;k fel, hogy szeretn&eacute;nk egy alap programot &iacute;rni, amiben k&eacute;tszer szeretn&eacute;nk ki&iacute;ratni egym&aacute;s ut&aacute;n egy bizonyos sz&ouml;veget. Előzetes tanulm&aacute;nyaink sor&aacute;n csak a szekvencia vagy a ciklusok &aacute;lltak rendelkez&eacute;s&uuml;nkre. Most, a fork() haszn&aacute;lat&aacute;val is meg tudjuk ezt tenni, amelyet az &lt;unistd.h&gt; headerből kapunk. Az al&aacute;bbi programban a main() f&uuml;ggv&eacute;ny legelej&eacute;n kl&oacute;noz&aacute;st hajtunk v&eacute;gre &ndash; ami azt jelenti, hogy az elindul&oacute; programot, mint folyamatot megkettőzz&uuml;k. &Iacute;gy a termin&aacute;lban egym&aacute;s ut&aacute;n k&eacute;tszer fog megjelenni a ki&iacute;rand&oacute; sz&ouml;veg, mivel kettő folyamattal dolgozunk.</span></p>
<pre>#include &lt;stdio.h&gt;<br />#include &lt;sys/types.h&gt;<br />#include &lt;unistd.h&gt;<br /><br />int main() {<br />   fork();<br /><br />   printf("Hello World!\n");<br /><br />   return 0;<br />}</pre>
<p><span style="font-size: 14pt;">Az eredm&eacute;ny:</span></p>
<pre>Hello World!<br />Hello World!</pre>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://canvas.instructure.com/courses/13939147/files/333256283/preview" alt="output-fork-function.webp" width="60%" height="60%" data-api-endpoint="https://canvas.instructure.com/api/v1/courses/13939147/files/333256283" data-api-returntype="File" /></p>
<p><span style="font-size: 14pt;">Mivel minden esetben duplik&aacute;ci&oacute; t&ouml;rt&eacute;nik, ez&eacute;rt a 2 n-szeres hatv&aacute;nyak&eacute;nt hivatkozhatunk a folyamatok darabsz&aacute;m&aacute;ra, ahol n a fork() rendszerh&iacute;v&aacute;sok sz&aacute;m&aacute;t jel&ouml;li. Ha az előbbi programunkban nem egyetlen fork(), hanem h&aacute;rom kap helyet, akkor a kimeneten 8 darab "Hello World!" ki&iacute;r&aacute;s fog szerepelni.</span></p>
<p><span style="font-size: 14pt;">A forkol&aacute;st gyakran hibakezel&eacute;s k&ouml;veti. Egy h&aacute;rom&aacute;g&uacute; if-ben c&eacute;lszerű megvizsg&aacute;lni a kapott visszat&eacute;r&eacute;si &eacute;rt&eacute;ket, &iacute;gy a hib&aacute;k &eacute;s a sz&uuml;lő-gyerek viszontags&aacute;gok felder&iacute;thetők.</span></p>
<pre>pid_t child = fork();<br /><br />if (child &lt; 0) {<br />   perror("The fork calling was not successful\n"); // &lt;errno.h&gt;-ban tal&aacute;lhat&oacute; hibakezel&eacute;s<br />   exit(1); // 1-es hibak&oacute;ddal kil&eacute;p&uuml;nk<br />} else if (child &gt; 0) {<br />   printf("Parent process is running\n");<br />} else {<br />   printf("Child process is running\n");<br />}</pre>
<p><span style="font-size: 14pt;">A folyamatkezel&eacute;s t&eacute;mak&ouml;r&eacute;ben sz&aacute;mos olyan f&uuml;ggv&eacute;ny &aacute;ll rendelkez&eacute;s&uuml;nkre, amellyel megk&ouml;nny&iacute;thetj&uuml;k a munk&aacute;nkat.&nbsp;</span></p>
<ul>
<li><span style="font-size: 14pt;">getpid(): lek&eacute;rj&uuml;k az aktu&aacute;lis folyamat azonos&iacute;t&oacute;j&aacute;t.</span></li>
</ul>
<pre>pid_t pid = fork();<br />printf("Process ID: %d\n", getpid());</pre>
<ul>
<li><span style="font-size: 14pt;">getppid(): visszaadja az aktu&aacute;lis folyamat sz&uuml;lőfolyamat&aacute;nak azonos&iacute;t&oacute;j&aacute;t, amennyiben a folyamatot fork() seg&iacute;ts&eacute;g&eacute;vel hoztuk l&eacute;tre. Ellenkező esetben 1-gyel t&eacute;r vissza, amely az init processz azonos&iacute;t&oacute;ja.</span></li>
</ul>
<pre>pid_t pid = fork();<br />printf("Parent Process ID: %d\n", getppid());</pre>
<ul>
<li><span style="font-size: 14pt;">wait(int *status): sz&uuml;lőfolyamatn&aacute;l haszn&aacute;ljuk, hogy v&aacute;rakozzon, am&iacute;g az egyik gyere be nem fejezi a fut&aacute;st. Nincs megszabva, melyik gyerekfolyamat termin&aacute;l&aacute;s&aacute;ig v&aacute;rakozik. A termin&aacute;l&oacute; gyerek azonos&iacute;t&oacute;j&aacute;t adja vissza. Ha nincs gyerek, azonnal -1 &eacute;rt&eacute;ket dob. Param&eacute;terk&eacute;nt st&aacute;tuszt kap, amely a kil&eacute;p&eacute;si inform&aacute;ci&oacute;kat tartalmazza.</span></li>
</ul>
<pre>pid_t pid = fork();<br /><br />if (pid == 0) {<br />   printf("Child is running\n");<br />   return 5<br />}<br /><br />int status;<br />wait(&amp;status);<br /><br />printf("Child finished\n");<br />return 0;</pre>
<ul>
<li><span style="font-size: 14pt;">waitpid(pid_t pid, int *status, int options): sz&uuml;lőfolyamatn&aacute;l haszn&aacute;ljuk, de param&eacute;terk&eacute;nt &aacute;t kell adni, melyik gyerekre vonatkoz&oacute;an kell v&aacute;rakoznia. Ha a pid nagyobb 0-n&aacute;l, konkr&eacute;t azonos&iacute;t&oacute;ra v&aacute;r. Ha -1, akkor b&aacute;rmely gyerekfolyamat befejez&eacute;s&eacute;n&eacute;l elindul. A status tartalmazza a kil&eacute;p&eacute;si inform&aacute;ci&oacute;kat. Az options argumentum flageket hat&aacute;roz meg, amelyekkel a sz&uuml;lő-gyerek v&aacute;rakoz&aacute;si folyamat szabhat&oacute; meg.</span></li>
</ul>
<pre>pid_t pid = fork();<br /><br />if (pid == 0) {<br />   sleep(2);<br />   return 3;<br />}<br /><br />int status;<br />waitpid(pid, &amp;status, 0);<br />printf("Child finished\n");<br /><br />return 0;</pre>
<ul>
<li><span style="font-size: 14pt;">exec() f&uuml;ggv&eacute;nycsal&aacute;d: lecser&eacute;lik az aktu&aacute;lis folyamat programj&aacute;t egy m&aacute;sik programra. A folyamatazonos&iacute;t&oacute;t meghagyj&aacute;k, de a k&oacute;dot, a vermet &eacute;s a heapet megv&aacute;ltoztatj&aacute;k. Ebbe a csal&aacute;dba tartozik az execl(), execv(), execlp(), execvp(), execve().</span></li>
</ul>
<pre>pid_t pid = fork();<br /><br />if (pid == 0) {<br />   execl("/bin/ls", "ls", "-l", NULL); <br />   // ahol: execl("program_el&eacute;r&eacute;si_&uacute;t", "program_neve", "program_kapcsol&oacute;", "lista_v&eacute;ge");<br />} else {<br />   waitpid(pid, NULL, 0);<br />}</pre>
<ul>
<li><span style="font-size: 14pt;">signal(int signum, *handler): alapjel kezelő a f&uuml;ggv&eacute;ny, amely egy megadott szign&aacute;l eset&eacute;n valamilyen esem&eacute;nyt h&uacute;z maga ut&aacute;n.&nbsp;&nbsp;</span></li>
<li><span style="font-size: 14pt;">sleep(int seconds): meg&aacute;ll&iacute;tja az aktu&aacute;lis folyamat fut&aacute;s&aacute;t a megadott sz&aacute;m&uacute; m&aacute;sodperc erej&eacute;ig. Ezalatt a folyamat nem csin&aacute;l semmit, de m&aacute;s folyamatok kaphatnak a CPU-t&oacute;l időszeletet. Fel&eacute;breszthető egy jellel.</span></li>
<li><span style="font-size: 14pt;">pause(): meg&aacute;ll&iacute;tja a folyamat fut&aacute;s&aacute;t v&eacute;gtelen időre, am&iacute;g egy jel nem &eacute;rkezik. Jel hi&aacute;ny&aacute;ban blokkolva marad.</span></li>
</ul>
<pre>void handler(int signal) {<br />   printf("Signal received\n");<br />}<br /><br />int main() {<br />   signal(SIGINT, handler); // Ctrl+C kezel&eacute;se<br />   printf("Waiting for signal...\n");<br /><br />   pause();<br /><br />   printf("Finished!\n");<br />   return 0;<br />}</pre>
<p><span style="font-size: 14pt;">A st&aacute;tuszra vonatkoz&oacute; makr&oacute;kat egy t&aacute;bl&aacute;zatban &ouml;sszefoglalhatjuk funkci&oacute;ik szerint. Ezek a makr&oacute;k a &lt;sys/wait.h&gt; headerben tal&aacute;lhat&oacute;ak, &eacute;s leggyakrabban arra haszn&aacute;lhat&oacute;k, hogy kider&iacute;ts&uuml;k, a gyerekfolyamat hogyan fejeződ&ouml;tt be.</span></p>
<table style="border-collapse: collapse; width: 100%; height: 571.852px;" border="1">
<tbody>
<tr style="height: 88.9766px;">
<td style="width: 27.3876%; height: 88.9766px;"><span style="font-size: 14pt;">WIFEXITED(status)</span></td>
<td style="width: 72.6124%; height: 88.9766px;"><span style="font-size: 14pt;">Igaz &eacute;rt&eacute;ket ad, ha a gyerek hiba n&eacute;lk&uuml;l l&eacute;pett ki (exit()-tel vagy main() f&uuml;ggv&eacute;nyből).</span></td>
</tr>
<tr style="height: 60.9844px;">
<td style="width: 27.3876%; height: 60.9844px;"><span style="font-size: 14pt;">WEXITSTATUS(status)</span></td>
<td style="width: 72.6124%; height: 60.9844px;"><span style="font-size: 14pt;">Visszaadja a kil&eacute;p&eacute;si k&oacute;dot (pl. return &eacute;rt&eacute;k a main() f&uuml;ggv&eacute;ny v&eacute;g&eacute;n).</span></td>
</tr>
<tr style="height: 60.9844px;">
<td style="width: 27.3876%; height: 60.9844px;"><span style="font-size: 14pt;">WIFSIGNALED(status)</span></td>
<td style="width: 72.6124%; height: 60.9844px;"><span style="font-size: 14pt;">Igazzal t&eacute;r vissza, ha a gyerekfolyamat jel miatt &aacute;llt le.</span></td>
</tr>
<tr style="height: 32.9922px;">
<td style="width: 27.3876%; height: 32.9922px;"><span style="font-size: 14pt;">WTERMSIG(status)</span></td>
<td style="width: 72.6124%; height: 32.9922px;"><span style="font-size: 14pt;">Melyik jel miatt &aacute;llt le.</span></td>
</tr>
<tr style="height: 172.953px;">
<td style="width: 27.3876%; height: 172.953px;"><span style="font-size: 14pt;">WCOREDUMP(status)</span></td>
<td style="width: 72.6124%; height: 172.953px;"><span style="font-size: 14pt;">Igaz &eacute;rt&eacute;kű, ha a folyamat core dumpot k&eacute;sz&iacute;tett (snapshot a program munkamem&oacute;ri&aacute;j&aacute;r&oacute;l, processzorregisztereiről, abban az esetben, ha a program &ouml;sszeomlik vagy le&aacute;ll).</span></td>
</tr>
<tr style="height: 60.9844px;">
<td style="width: 27.3876%; height: 60.9844px;"><span style="font-size: 14pt;">WIFSTOPPED(status)</span></td>
<td style="width: 72.6124%; height: 60.9844px;"><span style="font-size: 14pt;">Igazat ad, ha a gyerek stop szign&aacute;l miatt &aacute;llt meg.</span></td>
</tr>
<tr style="height: 32.9922px;">
<td style="width: 27.3876%; height: 32.9922px;"><span style="font-size: 14pt;">WSTOPSIG(status)</span></td>
<td style="width: 72.6124%; height: 32.9922px;"><span style="font-size: 14pt;">Melyik stop jel miatt &aacute;llt meg.</span></td>
</tr>
<tr style="height: 60.9844px;">
<td style="width: 27.3876%; height: 60.9844px;"><span style="font-size: 14pt;">WIFCONTINUED(status)</span></td>
<td style="width: 72.6124%; height: 60.9844px;"><span style="font-size: 14pt;">Igazzal t&eacute;r vissza, amennyiben a folyamat folytat&oacute;dott egy SIGCONT jel ut&aacute;n.</span></td>
</tr>
</tbody>
</table>
<p><span style="font-size: 14pt;">A waitpid() f&uuml;ggv&eacute;ny harmadik argumentumak&eacute;nt megkapott opci&oacute;k r&eacute;szben k&uuml;l&ouml;nf&eacute;le flagek rendelhetők hozz&aacute;.&nbsp;</span></p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td style="width: 30.0533%;"><span style="font-size: 14pt;">0</span></td>
<td style="width: 69.9467%;"><span style="font-size: 14pt;">Alap&eacute;rtelmezett &eacute;rt&eacute;k. Blokkol&oacute; v&aacute;rakoz&aacute;s a gyerek befejeződ&eacute;s&eacute;re.</span></td>
</tr>
<tr>
<td style="width: 30.0533%;"><span style="font-size: 14pt;">WNOHANG</span></td>
<td style="width: 69.9467%;"><span style="font-size: 14pt;">Nem blokkol&oacute; utas&iacute;t&aacute;s, ha a gyerek m&eacute;g fut, automatikusan 0 &eacute;rt&eacute;kkel t&eacute;r&uuml;nk vissza.</span></td>
</tr>
<tr>
<td style="width: 30.0533%;"><span style="font-size: 14pt;">WUNTRACED</span></td>
<td style="width: 69.9467%;"><span style="font-size: 14pt;">Igaz &eacute;rt&eacute;ket ad, ha a gyerek meg&aacute;llt valamilyen szign&aacute;l hat&aacute;s&aacute;ra, norm&aacute;l WIFSTOPPED eset&eacute;n.</span></td>
</tr>
<tr>
<td style="width: 30.0533%;"><span style="font-size: 14pt;">WCONTINUED</span></td>
<td style="width: 69.9467%;"><span style="font-size: 14pt;">Igaz &eacute;rt&eacute;ket ad, ha a folyamat folytat&oacute;dik.</span></td>
</tr>
<tr>
<td style="width: 30.0533%;"><span style="font-size: 14pt;">WEXITED</span></td>
<td style="width: 69.9467%;"><span style="font-size: 14pt;">Csak a befejezett folyamatokra v&aacute;r. A modern Linux rendszereken haszn&aacute;lhat&oacute;.</span></td>
</tr>
<tr>
<td style="width: 30.0533%;"><span style="font-size: 14pt;">__WALL, __WCLONE</span></td>
<td style="width: 69.9467%;"><span style="font-size: 14pt;">Speci&aacute;lis flagek t&ouml;bb sz&aacute;l &eacute;s folyamat kezel&eacute;s&eacute;re.</span></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><span style="text-decoration: underline;"><strong><span style="font-size: 18pt;">Z&aacute;rol&aacute;s</span></strong></span></p>
<p><span style="font-size: 14pt;">A p&aacute;rhuzamos &eacute;s t&ouml;bbsz&aacute;l&uacute; programoz&aacute;s egy meghat&aacute;roz&oacute; eleme a z&aacute;rol&aacute;s. Amikor t&ouml;bb sz&aacute;l vagy t&ouml;bb folyamat egyidejűleg f&eacute;r hozz&aacute; ugyanahhoz az osztott adathoz, amely lehet egy t&ouml;mb, egy f&aacute;jl stb., akkor az adatok inkonzisztenss&eacute; v&aacute;lthatnak. T&ouml;bbsz&ouml;ri hozz&aacute;f&eacute;r&eacute;s eset&eacute;n nincs meghat&aacute;rozva a hozz&aacute;f&eacute;r&eacute;s sorrendje, a v&eacute;letlenszerűs&eacute;g pedig sz&aacute;mos, nehezen reproduk&aacute;lhat&oacute; adathib&aacute;t eredm&eacute;nyezhet nemdeterminisztikus m&oacute;don. Ezeket az eseteket versenyhelyzetnek nevezz&uuml;k.</span></p>
<p><span style="font-size: 14pt;">B&aacute;r &aacute;ltal&aacute;ban az ehhez hasonl&oacute; probl&eacute;m&aacute;kat sz&aacute;lkezel&eacute;sn&eacute;l tapasztalj&aacute;k, a folyamatok sor&aacute;n is ad&oacute;dhatnak gondok, hiszen megosztott erőforr&aacute;sokkal dolgozhatnak.</span></p>
<p><span style="font-size: 14pt;">Kritikus szakasznak nevezz&uuml;k azokat a k&oacute;dr&eacute;szleteket, amelyet egyszerre kiz&aacute;r&oacute;lag egy folyamat hajthat v&eacute;gre. Ahol nem engedhetj&uuml;k meg, hogy t&ouml;bbsz&ouml;ri f&aacute;jlba &iacute;r&aacute;s, v&aacute;ltoz&oacute; m&oacute;dos&iacute;t&aacute;s vagy adatstrukt&uacute;ra m&oacute;dos&iacute;t&aacute;s t&ouml;rt&eacute;njen, ott a z&aacute;rol&aacute;s (lock haszn&aacute;lat) elengedhetetlen. Ehhez az &lt;fcntl.h&gt; header f&aacute;jlt haszn&aacute;ljuk.</span></p>
<p><span style="font-size: 14pt;">A flock() f&uuml;ggv&eacute;ny az egyik legegyszerűbb z&aacute;rol&aacute;st biztos&iacute;tja. Első param&eacute;terek&eacute;nt &aacute;t kell adni a f&aacute;jl megnyit&aacute;s&aacute;nak visszat&eacute;r&eacute;si &eacute;rt&eacute;k&eacute;t, majd egy f&aacute;jlz&aacute;rol&aacute;si t&iacute;pust.</span></p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td style="width: 17.2874%;">LOCK_SH</td>
<td style="width: 82.8902%;">Megosztott z&aacute;rol&aacute;s. T&ouml;bb folyamat is olvashatja egyszerre a f&aacute;jlt.</td>
</tr>
<tr>
<td style="width: 17.2874%;">LOCK_EX</td>
<td style="width: 82.8902%;">Kiz&aacute;r&oacute;lagos z&aacute;rol&aacute;s. Egyszerre csak egy folyamat haszn&aacute;lhatja a f&aacute;jlt.</td>
</tr>
<tr>
<td style="width: 17.2874%;">LOCK_UN</td>
<td style="width: 82.8902%;">Z&aacute;rol&aacute;s felold&aacute;sa.</td>
</tr>
<tr>
<td style="width: 17.2874%;">LOCK_NB</td>
<td style="width: 82.8902%;">Nem v&aacute;rakozik, ha nem tudja megszerezni a kulcsot a z&aacute;rol&aacute;s felold&aacute;s&aacute;hoz. Ekkor hib&aacute;val t&eacute;r vissza.</td>
</tr>
</tbody>
</table>
<p><span style="font-size: 14pt;">A k&ouml;vetkező mintak&oacute;d egy kiz&aacute;r&oacute;lagos z&aacute;rol&aacute;st val&oacute;s&iacute;t meg. Kettő folyamattal dolgozunk a main() f&uuml;ggv&eacute;ny eleji forkol&aacute;s &aacute;ltal, majd kiz&aacute;r&oacute;lagos z&aacute;rol&aacute;st adunk a megnyitott f&aacute;jlra. Ez azt jelenti, hogy a sz&uuml;lő &eacute;s gyerek folyamat fut&aacute;s&aacute;t szab&aacute;lyozzuk, &eacute;s nem engedj&uuml;k, hogy a f&aacute;jlba &iacute;rt eredm&eacute;nyt a kettő sz&ouml;veg v&eacute;letlenszerű permut&aacute;ci&oacute;ja legyen.</span></p>
<pre>#include &lt;fcntl.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;sys/file.h&gt;<br /><br />int main() {<br />   pid_t pid = fork();<br />   <br />   int file = open("data.txt", O_WRONLY | O_APPEND);<br />   flock(file, LOCK_EX);<br /><br />   const char *message1 = "Hello World from child process.\n";<br />   const char *message2 = "Hello World from parent process.\n";<br /><br />   if (pid == 0) {<br />      write(file, message1, strlen(message1));<br />   } else if (pid &gt; 0) {<br />      write(file, message2, strlen(message2));<br />   }<br /><br />   flock(file, LOCK_UN);<br />   close(file);<br /><br />   return 0;<br />}</pre>
<p><span style="font-size: 14pt;">A z&aacute;rol&aacute;s garant&aacute;lja az atomi &iacute;r&aacute;st, azonban nem garant&aacute;lja a sz&uuml;lő- &eacute;s gyerekfolyamat &iacute;r&aacute;s&aacute;nak sorrendj&eacute;t.&nbsp;</span></p>
<p><span style="font-size: 14pt;">Egy bonyolultabb, finomhangoltabb f&aacute;jlz&aacute;rol&aacute;st val&oacute;s&iacute;t meg az fcntl() f&uuml;ggv&eacute;ny. Az fcntl() egy flock strukt&uacute;r&aacute;t haszn&aacute;l, amely a f&aacute;jlz&aacute;rol&aacute;s hozz&aacute;f&eacute;r&eacute;sek koordin&aacute;l&aacute;s&aacute;ra szolg&aacute;l. A flock a k&ouml;vetkező mezőkkel rendelkezik:</span></p>
<pre>struct flock {<br />   short l_type; // z&aacute;rol&aacute;s t&iacute;pusa<br />   short l_whence; // f&aacute;jlmutat&oacute;<br />   off_t l_start; // kezdőpoz&iacute;ci&oacute;<br />   off_t l_len; // z&aacute;rol&aacute;s hossza<br />   pid_t l_pid; // z&aacute;rol&oacute; folyamat PID-je<br />}</pre>
<p><span style="font-size: 14pt;">Az l_type a z&aacute;rol&aacute;s t&iacute;pus&aacute;t adja meg. Megk&uuml;l&ouml;nb&ouml;ztethet&uuml;nk olvas&aacute;si z&aacute;rol&aacute;st (F_RDLCK), amely eset&eacute;ben az olvas&aacute;st t&ouml;bb folyamat is v&eacute;grehajthatja azonos időben. &Iacute;r&aacute;si z&aacute;rol&aacute;st (F_WRLCK), ahol csak egy &iacute;r&oacute; folyamat lehet, minden m&aacute;s &iacute;r&aacute;s-olvas&aacute;si művelet a folyamatokban blokkolt. Az F_UNLCK a z&aacute;rol&aacute;s felold&aacute;sa, ezut&aacute;n a f&aacute;jl &uacute;jra el&eacute;rhető t&ouml;bb processz sz&aacute;m&aacute;ra.</span></p>
<p><span style="font-size: 14pt;">Az l_whence mező a f&aacute;jl m&oacute;dos&iacute;t&aacute;s&aacute;nak kezdőpoz&iacute;ci&oacute;j&aacute;&eacute;rt felel. A 2. gyakorlati anyagban taglalt SEEK_SET a f&aacute;jl elej&eacute;ről, a SEEK_CUR a jelenlegi f&aacute;jlmutat&oacute;t&oacute;l, a SEEK_END a f&aacute;jl v&eacute;g&eacute;től sz&aacute;m&iacute;tja a kezdőpoz&iacute;ci&oacute;t.&nbsp;</span></p>
<p><span style="font-size: 14pt;">Az l_start mező a z&aacute;rol&aacute;s kezdőpoz&iacute;ci&oacute;j&aacute;nak eltol&aacute;sa az l_whence-hez k&eacute;pest. Az l_len a lockolt szakasz hossz&aacute;t tartalmazza, amely abban az esetben vehet fel 0 &eacute;rt&eacute;ket, ha a z&aacute;rol&aacute;s a f&aacute;jl v&eacute;g&eacute;től a kezdőpontig tart. Ergo, ha az eg&eacute;sz f&aacute;jlra vonatkozik a z&aacute;rol&aacute;s. Az l_pid az aktu&aacute;lis z&aacute;rol&oacute; folyamat azonos&iacute;t&oacute;j&aacute;t jel&ouml;li.</span></p>
<p><span style="font-size: 14pt;">Az fcntl(int file, int cmd, struct flock *lock) f&uuml;ggv&eacute;ny első param&eacute;terk&eacute;nt egy olyan eg&eacute;sz sz&aacute;mot kap, amelyet az open rendszerh&iacute;v&aacute;ssal egy f&aacute;jl megnyit&aacute;sa ut&aacute;n kapunk. A cmd param&eacute;ter azt mondja meg, milyen műveletet akarunk v&eacute;gezni a f&aacute;jl le&iacute;r&oacute;j&aacute;val, vagyis a z&aacute;rol&aacute;ssal. Az F_GETLK lek&eacute;rdezi, hogy a megadott tartom&aacute;ny z&aacute;rolhat&oacute;-e. Ha nem z&aacute;rolt, akkor &eacute;rtelemszerűen a harmadik param&eacute;terben megadott lock strukt&uacute;ra l_type mezőj&eacute;nek &eacute;rt&eacute;ke F_UNLCK. Ha z&aacute;rolt, visszaadja, ki &eacute;s milyen m&oacute;don z&aacute;rolta. Az F_SETLK nem blokkol&oacute; z&aacute;rol&aacute;st &eacute;s felold&aacute;st val&oacute;s&iacute;t meg. Ha a z&aacute;rol&aacute;s nem siker&uuml;l &ndash; mert m&aacute;r m&aacute;s valaki z&aacute;rolja az adott f&aacute;jlt valamilyen m&oacute;don &ndash;, hib&aacute;t &eacute;s -1 &eacute;rt&eacute;ket ad vissza. Az F_SETLKW ezzel szemben v&aacute;rakozik m&aacute;s folyamat z&aacute;rol&aacute;sa eset&eacute;n. Fontos, hogy az fcntl() egy f&aacute;jlr&eacute;szt is k&eacute;pes z&aacute;rolni, nem csak az eg&eacute;sz f&aacute;jlt.</span></p>
<p><span style="font-size: 14pt;">N&eacute;zz&uuml;nk r&aacute; egy mintak&oacute;dra. Ebben k&eacute;t folyamattal dolgozunk, &eacute;s mindk&eacute;t folyamat saj&aacute;t sz&ouml;veggel rendelkezik, amelyet a data.txt f&aacute;jlba &iacute;r. Azonban z&aacute;rol&aacute;st haszn&aacute;lunk: a lock seg&iacute;ts&eacute;g&eacute;vel mindk&eacute;t folyamat le&iacute;rhatja 10-szer a megadott &uuml;zenet&eacute;t megszak&iacute;t&aacute;s n&eacute;lk&uuml;l. Az &iacute;r&aacute;s előtt mindegyik folyamat lez&aacute;rja a f&aacute;jlt, majd fel is oldja.</span></p>
<pre>#include &lt;sys/file.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;string.h&gt;<br /><br />int main() {<br />   pid_t pid = fork;<br /><br />   const char *message1 = "Hello World from child process.\n";<br />   const char *message2 = "Hello World from parent process.\n";<br /><br />   struct flock lock_data;<br />   lock_data.l_whence = SEEK_SET;<br />   lock_data.l_start = 0;<br />   lock_data.l_len = 0;<br /><br />   int lock_result = 0;<br />   int file = open("data.txt", O_WRONLY | O_APPEND);<br /><br />   if (pid &gt; 0) {<br /> &nbsp; &nbsp; &nbsp;for (int i = 0; i &lt; 10; i++) {<br />         lock_data.l_pid = getpid();<br />         lock_data.l_type = F_WRLCK;<br /><br />  &nbsp; &nbsp; &nbsp;  lock_result = fcntl(file, F_SETLKW, &amp;lock_data); <br />  &nbsp; &nbsp; &nbsp;  if (lock_result != -1) { <br />  &nbsp; &nbsp; &nbsp;     for (size_t i = 0; i &lt; strlen(message2); i++) {<br />  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    write(file, &amp;message2[i], 1); //karakterenk&eacute;nt &iacute;r&aacute;s<br />  &nbsp; &nbsp; &nbsp;        usleep(20); //20 nanosec<br />  &nbsp; &nbsp; &nbsp;     }<br />  &nbsp; &nbsp; &nbsp;     write(file, "\n", 1);<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />  &nbsp; &nbsp; &nbsp;     lock_data.l_type = F_UNLCK;<br />  &nbsp; &nbsp; &nbsp;     fcntl(file, F_SETLKW, &amp;lock_data);<br />         }<br />  &nbsp; &nbsp; } <br />   } else if (pid == 0) {<br />      for (int i = 0; i &lt; 10; i++) {<br />         lock_data.l_pid = getpid();<br />         lock_data.l_type = F_WRLCK;<br /><br /><br />  &nbsp; &nbsp; &nbsp; &nbsp;lock_result = fcntl(file, F_SETLKW, &amp;lock_data); <br />  &nbsp; &nbsp; &nbsp; &nbsp;if (lock_result != -1) { <br />  &nbsp; &nbsp; &nbsp; &nbsp;   for (size_t i = 0; i &lt; strlen(message1); i++) {<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   write(file, &amp;message1[i], 1); //karakterenk&eacute;nt &iacute;r&aacute;s<br />  &nbsp; &nbsp; &nbsp; &nbsp;      usleep(20); //20 nanosec<br />  &nbsp; &nbsp; &nbsp; &nbsp;   }<br />  &nbsp; &nbsp; &nbsp; &nbsp;   write(file, "\n", 1);<br />  &nbsp; &nbsp; &nbsp; &nbsp;   <br />  &nbsp; &nbsp; &nbsp; &nbsp;   lock_data.l_type = F_UNLCK;<br />  &nbsp; &nbsp; &nbsp; &nbsp;   fcntl(file, F_SETLKW, &amp;lock_data);<br />  &nbsp; &nbsp; &nbsp; &nbsp;}<br />      }<br />   }<br /><br />   close(file);<br /><br />   return 0;<br />}</pre>
<p>&nbsp;</p>
<p><span style="text-decoration: underline; font-size: 14pt; background-color: #c2e0f4;"><strong>&Oacute;rai feladatok:</strong></span></p>
<p><span style="font-size: 14pt;">K&eacute;sz&iacute;ts&uuml;nk egy olyan programot, amely a felhaszn&aacute;l&oacute;t&oacute;l bek&eacute;ri, hogy h&aacute;ny sz&uuml;lő- &eacute;s gyerekfolyamat ki&iacute;rat&aacute;st szeretn&eacute;nk l&aacute;tni a termin&aacute;lban! A sz&uuml;lő sz&ouml;vege az "I am the parent!", a gyerek sz&ouml;vege pedig "And?" legyen! &Iacute;rassuk ki tov&aacute;bb&aacute; a sz&uuml;lő &eacute;s a gyerek ID-j&aacute;t is!</span></p>
<p><span style="font-size: 14pt;">&Iacute;rjunk olyan programot, amely teljes&iacute;ti az al&aacute;bbi felt&eacute;teleket. Elősz&ouml;r l&eacute;trehoz egy gyereket, majd a gyerek ki&iacute;rja, hogy elindult, alszik 5 m&aacute;sodpercig, &eacute;s 7-tel termin&aacute;l. A sz&uuml;lő megv&aacute;rja, hogy a gyerek v&eacute;gezzen, ki&iacute;rja a PID-j&aacute;t, ezt k&ouml;vetően kiolvassa &eacute;s ki&iacute;rja a kil&eacute;p&eacute;si k&oacute;dj&aacute;t.</span></p>
<p><span style="font-size: 14pt;">Hozzunk l&eacute;tre 3 gyerekfolyamatot! V&eacute;letlenszerű &eacute;rt&eacute;ket kapjanak ahhoz, hogy meddig alszanak (1-10 m&aacute;sodperc intervallumon), mi a kil&eacute;p&eacute;si k&oacute;djuk. A sz&uuml;lő v&aacute;rja meg mindegyik folyamatot, &eacute;s &iacute;rja ki egyes&eacute;vel, melyik gyerekfolyamat mikor fejeződ&ouml;tt be, &eacute;s milyen st&aacute;tusszal! A ki&iacute;rat&aacute;s az al&aacute;bbi form&aacute;ban t&ouml;rt&eacute;njen:</span></p>
<p><span style="font-size: 14pt;">{PID} process successfully finished at {timestamp} with status code {state}.</span></p>
<p><span style="font-size: 14pt;">&Iacute;rjunk olyan programot, ahol forkol&aacute;s ut&aacute;n kicser&eacute;lj&uuml;k a gyerekfolyamat programj&aacute;t a ps folyamatlek&eacute;rdező parancsra! A sz&uuml;lőfolyamat v&aacute;rja meg a befejez&eacute;s&eacute;t, majd &iacute;rja ki, hogy a ps lefutott!</span></p>
<p><span style="font-size: 14pt;">K&eacute;sz&iacute;ts&uuml;nk olyan C forr&aacute;sf&aacute;jlt, amelyben k&eacute;t folyamat egy-egy stringet &iacute;r ugyanabba az adatf&aacute;jlba. Futtassuk a programot z&aacute;rol&aacute;s haszn&aacute;lata n&eacute;lk&uuml;l is, &eacute;s ezut&aacute;n &iacute;rjuk &aacute;t z&aacute;rol&aacute;sos &ndash; flock() &ndash; megold&aacute;sra!</span></p>
<p><span style="font-size: 14pt;">Haszn&aacute;ljuk ki az fcntl() f&uuml;ggv&eacute;nyt, &eacute;s &iacute;rjunk olyan k&oacute;dot, amelyben n&eacute;gy folyamat, egyenk&eacute;nt 5-5 sort &iacute;r bele egy f&aacute;jlba. Z&aacute;roljuk az eg&eacute;sz f&aacute;jlt, &eacute;s n&eacute;zz&uuml;k meg az eredm&eacute;nyt!</span></p>
<p><span style="font-size: 14pt;">&Iacute;rjunk programot, amely csak a f&aacute;jl első fel&eacute;t z&aacute;rolja az egyik folyamat &aacute;ltal!&nbsp;</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 8pt;">A 3. gyakorlat tananyag&aacute;hoz felhaszn&aacute;lt gyakorlati anyag: gy1/exec.c, fcntl_0.c, fcntl.c, fork.c, rand.c, system.c, write.c.</span></p>